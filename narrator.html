<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Narrator</title>
    <style type="text/css">
      html {
        font-size: 18px;
        background-color: rgb(255, 238, 218);
      }

      body {
        /* margin-top: 5%; */
        padding: 0;
        margin: 0;
      }

      .main {
        max-width: 50%;
        margin: 0 auto;
        padding: 2rem;
        background-color: bisque;
      }

      .readable {
        font-size: 1.25rem;
        line-height: 1.75rem;
      }
    </style>
  </head>

  <body>
    <div class="main readable" id="narrator">
      (classical music) - [Lecturer] In this challenge, we'll step outside
      common layout practices to explore the cutting edge of CSS layouts by
      using container queries. And I recommend you go check out the MDN article
      on container queries before trying to solve those challenge. When working
      with modules like cards, we often want to change their internal layout
      based on the space available for each component. This can be achieved
      using container queries. These are media queries that are tied to the
      width of a container or the height of a container or some other property
      instead of the viewport. You can see an example of it here. So when the
      viewport is wide it means that the container is also wide. And then you
      get this side by a layout. But when I reduce the width of the viewport, it
      also reduces the width of the container and eventually it'll change its
      layout. Now, this could be done using a media query for the content width
      but I actually want it to happen inside the container so that different
      cards displayed at different places will change their layouts depending on
      their available space, rather than depending on the total width of the
      viewport. So that's what we're trying to achieve here. Oh, and one caveat.
      As of this recording container queries are only supported in the Chrome
      browser. So use Chrome for testing and experimentation. In this challenge,
      the layout should appear as a vertical stack. So image, heading, text,
      button, when there is limited horizontal space and change to a display
      where the image is on the left and the text and the button is on the
      right, when there is sufficient horizontal space inside the container and
      this should happen for each card individually. To test, change the
      viewport width and see the card vary with the width. In the exercise files
      for this challenge, we have again, the single card, HTML has not changed.
      And also the CSS has not changed. This is the same CSS we worked with
      earlier in a previous challenge. Now you take on this challenge. Pause the
      video here, find your solution. Then come back, hit play and see how I
      solve the same challenge. (classical music) The idea of container query is
      you define a container as the baseline for the query and then query some
      parameter of that container. For example, we can define the figure as a
      container and then query the width of the figure and create custom layouts
      inside the figure based on the current width. To get this to work, we need
      to commit what I often refer to as a web standards crime that is adding in
      a div that doesn't really have any purpose other than for layout purposes.
      So here, because I'm adding a query to the figure, I need to have
      something to apply the changes to. So I'm going to add an extra div inside
      the figure. So I'll say div and give it the class card-inner. Then I'll
      take the end div tag and place it right before the end figure tag down
      here. So now we can query the figure and then apply any changes to
      card-inner and what is inside card-inner. Okay, the next step is we need
      to tell the browser which container is now being queried. And we do that
      by adding the new container type property to that container. So in this
      case, we're querying the card container. So I'll say container
      container-type colon, and then we're looking for inline size. We're
      looking for the horizontal size of the container. So I'll say inline-size.
      You'll notice when I do this, that VS Code is like, "Hey, hey, hey, what
      exactly is container type?" This is so bleeding edge that VS Code doesn't
      yet know that this is a property in CSS, but trust me, this will actually
      work in Chrome. And like I said, it only works in Chrome right now, but it
      does work. Now that we've set card as a container-type: inline-size,
      meaning we are querying the width of the current container, we can set up
      a query. That query looks like this @container, and that means at the
      first available container you see higher up in the stack, which is this
      one right here. Then I say min-width and set it to a value. So let's say
      60ch. And then we can do things to what's inside that container. So here,
      I'll say card-inner, and set card-inner to display: flex. Then I'll grab
      all the direct descendants of card-inner and set them to 50%. So the
      direct descendants of the card-inner is the image and the figcaption. So
      that will work fine. So I'll say card-inner and then any descendant of
      that, we'll set max-width: 50%. And then finally I want the image to not
      be squished but instead take up all the available space. So I'll say card
      and then image, and I'll set this to object-fit: cover. All right, save
      that, jump back into Chrome. And now you see, we have a different layout.
      So the card now has two columns, one for the image and one for the text
      and the image is stretching to fill that column. And if I changed a width
      of this card now, eventually we'll hit that break point inside the card
      width where we get the vertical stack instead. That's it, that's the
      solution to this challenge.
    </div>

    <script type="text/javascript">
      window.addEventListener("load", function () {
        const fullStopRegex = /\./g;
        const narrator = document.getElementById("narrator");
        narrator.innerHTML = narrator.innerHTML.replace(
          fullStopRegex,
          ".<br /><br />"
        );
      });
    </script>
  </body>
</html>
